= イテレーティブなローカル環境の構成管理方法の検討

== はじめに

本章ではローカル環境の構成管理というテーマの下、課題感を含めた現状認識の整理と、解決に必要な要件の整理・実現方法の検討までを行います。

== 構成管理についての現状認識

=== なぜローカル環境での構成管理は浸透しないのか

構成管理という言葉を聞くと、一般的には Ansible や Chef、或いは CloudFormation や Terraform などのツールを思い浮かべるかもしれません。これらは、サーバーやインフラの構成をコードとして管理するため、本番環境で主に使われるものかと思われます。

一方で開発環境、特に個人のローカルマシン上での構成管理において、これらのツールを使っているケースは比較的少ないように思われます。これには幾つかの理由が考えられます。

 1. @<b>{イテレーションとのトレードオフ懸念}: ローカル環境の構成をコードベースで管理してしまうと、新たなツールを自由に試せなくなってしまい、かえって開発のスピードが落ちてしまうのではないかという懸念
 2. @<b>{共通化基準が不明}: ローカル環境で必要とされるツールやライブラリの自由度が高く、また人によって必要十分な構成がバラバラで、どこまで共通化出来るのかが不明
 3. @<b>{見切り発車}: 初期のスピード重視で構成管理を行わないまま開発をスタートしてしまい、今更構成管理を行うのが難しい
 4. @<b>{コストパフォーマンスの悪さ}: 上記の問題を解決しながら構成管理ツールを導入して得られるメリットとコストが釣り合わない

これらの問題は既存の構成管理ツールでもなかなか解決が難しいのではないかと思われます。というのも、構成管理ツールは本来、サーバーやインフラの構成などといった、もっと単純な (stateless な) マシンの構成を管理するためのツールであり、一般にもっと複雑な (stateful な) 個人のローカルマシンの構成を管理するためのツールではないからです。勿論完全に不可能ではないですが、ローカルマシン向けの細かい tips を積み重ねたとしても、@<b>{共通化基準が不明}という問題から他の人にとっても役立つかどうかが怪しく、過剰な学習コストを払ってしまったり、後からの保守が難しくなってしまうリスクさえもあったりする訳です。

=== ローカル環境での構成管理を実現した時に得られるメリット

上記のような課題意識はありつつも、構成管理のメリットは本番環境でのみ享受出来れば良いものではなく、ローカル環境でも十分価値のあるものです。チームでの開発においては、環境の差異による各種トラブルシューティングの削減が期待できます。個人開発においても、手慣れた環境を素早く構築出来ることが特に開発初期のスピード向上に大いに寄与するだけではなく、まぐれで上手くインストールできた環境を手軽に再現できるようになり、触ったことのある言語・ツールを資産として確実に残せるようになります。

== 求められる要件とその実現方法

メリットは意識しつつ、現状ではかなり課題がネックとなっている背景があることから、ここでは特に課題解決にフォーカスして実現方法を考えます。

まず課題意識を踏まえた上で、求められる要件は主に以下の 4 点に集約されます。

 1. @<b>{学習コストの低さ}: 独自の DSL やファイルフォーマットを出来る限り排除し、保守性の高い構成管理を目指す
 2. @<b>{汎用性の高さ}: 出来るだけ多くの設定ファイルをサポート出来るようにする
 3. @<b>{ポータビリティの高さ}: なるべく複雑な依存と機能を排し、どんな環境でも安定・一貫した結果を提供出来る
 4. @<b>{「遊び」を持たせる}: マシン毎に多少異なる構成を持つことを許容し、共通部分との差分を分かりやすくする

以下ではそれぞれの要件を満たすためのアーキテクチャ方針・技術選定について説明します。

=== 学習コストの低さ

これは Go のテンプレートエンジンをラップすることを基本としつつ、cue ファイルを用いた変数定義ファイルを別で設けることで実現します。

あくまでもテンプレートエンジンの内蔵に留めておくことで、以下のようなメリットが得られます。

 1. 簡単な変数とテンプレートファイルの組み合わせで構成管理が可能となり、入出力のペアが分かりやすい
 2. Go の標準テンプレートエンジンを用いることで、Go の文法を学ぶだけで良くなる
 3. 複数のテンプレートファイルを扱うことが可能となり、対応可能な設定ファイルの幅が広がる

特に 2. について言えば、CloudFormation や Terraform などの従来の構成管理ツールでは当たり前のように存在していた DSL を新たに学ぶ必要がなく、Go を採用しているプロジェクトであれば、ここで得た知識をそのまま活用することができ、払った学習コストも無駄になりづらいメリットがあります。

cue@<fn>{cue-lang} とは宣言的で型安全なデータ定義言語であり、主に以下のようなメリットが得られます。

 1. 型安全な変数定義が可能となり、より厳密な値のバリデーションも可能
 2. 公式に変数の参照がサポートされており、変数定義内での再利用が可能でより DRY を実現しやすい

JSON や TOML 等、よりメジャーなデータ定義言語では 2. の実現がそもそも難しいです。また、YAML には anchor & alias、hash の merge がありますが、これらを用いた時の記述は複雑になりがちで、かつ DRY を実現する上では微妙に足りない部分が多く、この手の要件ではかゆい所に手が届かない印象を受けます。これらのデータ定義言語の拡張も存在しますが、元の言語の仕様の曖昧さがついて回っていたずらに複雑になりがちです。こうした事情を加味しつつ、であれば最初から今回の要件を満たすようなシンプルな、全く別の独立した言語を選定した方が良いのではないかと考え、cue を選定に至りました。

=== 汎用性の高さ

前項と被りますが、「テンプレート」と「変数定義ファイル」を明示的に分けることで、汎用性の高さを実現できます。

VSCode の devcontainer という機能を例にとって考えてみましょう。設定は @<code>{devcontainer.json} と @<code>{docker-compose.yml} の、2 つの異なるフォーマットのファイルで構成されております。構成管理の都合上、これらのファイルを跨いで変数で共通化したいニーズが出てきますが、これを満たす上では大まかに以下の 2 つのアプローチが考えられます。

 1. 1 つの何らかのファイルに全ての変数、@<code>{devcontainer.json} と @<code>{docker-compose.yml} のテンプレートを記述してしまう
 2. JSON と YAML のそれぞれテンプレート、変数定義ファイルを別々に用意する

前者の具体的な方法としては、JSON が YAML のサブセットであることを考慮して YAML に全てをまとめるようなアプローチも考えられますが、実際にはかなりしんどいところです。@<b>{学習コストの低さ}で述べたメリットが得られず、特に入出力のペアが分かりづらくなって、保守性を著しく損なう恐れがあります。何より、devcontainer 以外の設定ファイルも汎用的にサポートすることを考えると、フォーマットを YAML に決め打って全ての設定ファイルをまとめていくのは現実的ではありません。

説明の便宜上設定ファイルが複数必要な場合のアプローチを挙げましたが、1 つのフォーマットに縛られてしまうデメリットは単一の設定ファイルにおいても同様です。

=== ポータビリティの高さ

当たり前ですが、ツールそれ自身がインストール時に複雑な依存を要求するようでは意味がありません。環境依存の挙動を徹底的に排し、どこでも手軽にインストールしてすぐに使えるようにする必要があります。

これも Go を採用することで自然と実現できます。一見 ShellScript や Python 等でも実現出来そうに思えますが、前者はシェルや OS に依存して挙動が変わってしまう部分が多いこと、後者はそもそも Python のバージョンに依存してしまうことから不採用としました。かと言ってスクリプト言語ではなく、バイナリを吐けるコンパイル言語であれば何でも良いかと言うとそういう訳でもなく、C 言語や Rust 等では libc 等への依存を排し切れない可能性があり、この観点でも Go の選定が最も適切に思えます。

=== 「遊び」を持たせる

最も本質的で、一番難しい要件です。今までの説明と少し矛盾しますが、ローカル環境において特に大事なのは@<b>{厳密に管理し過ぎないこと}です。これは課題感の項目で挙げた@<b>{イテレーションとのトレードオフ懸念}や@<b>{共通化基準が不明}の部分に該当します。

新しいツール等を試す目的でテンプレートから逸脱した構成となることがローカル環境ではしばしばあります。勿論これを放置しては構成管理の意味がなくなってしまいますが、かと言って厳密に管理し過ぎて手軽さをかえって損ね、開発のスピードが落ちてしまっても本末転倒です。また、どこまでをテンプレートとして持つかは往々にしてすぐには分からず、その時々によって最適な塩梅は容易に変わり得るものです。つまり、「敢えてテンプレート化せずに一旦保留」という「遊び」の選択肢を意図的に持たせることが必要になります。

これは以下の2 つの機能を実装することで解決できます。

 1. テンプレートを元に設定ファイルを生成する機能
 2. 生成した結果を追跡して、元のテンプレートとの差分を表示出来るような機能

後者について言えば、生成した先の設定ファイル群のディレクトリに専用の固有ファイルを配置し、どのテンプレートから生成されたものかを記録しておくことで実現できます。これによって、差分を見たい時に lazy に見ることが可能となり、テンプレートに含めるかを先送りにする「遊び」の選択肢を持たせることが出来ます。この先送りした部分が本当に必要かどうかは、例えば後で再利用したくなった時にでも改めて一括して見直すような運用でカバーすると良さそうです。こうした運用の下で、その時々での最適なテンプレートをその場で素早く組み直すことが可能となり、構成管理自体の保守性を低く保った状態でメリットを享受しやすくなるのではないかと思います。

== おわりに

「イテレーティブなローカル環境の構成管理」というテーマの下、これをツールとして実現する際に必要な要件を整理しました。本当はツールの実装まで行った上で、実際の改善例の提示等を行いたかったのですが...まだまだ絶賛開発途中ということもあり、一旦は簡単なコンセプトの共有までとさせてください。GitHub はこちら@<fn>{museum}です。

次回以降があれば、このツールの実装の詳細についての解説、更にこのツールを用いた実際の構成管理の改善例の紹介も出来ればと思います。乞うご期待ください。

//footnote[museum][https://github.com/at0x0ft/museum]
//footnote[cue-lang][https://cuelang.org/]
